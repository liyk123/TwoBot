// Generated by DeepSeek-R1

#include <atomic>
#include <shared_mutex>
#include <vector>
#include <list>
#include <memory>
#include <optional>
#include <functional>

template <typename Key, typename Value, typename Hash = std::hash<Key>>
class ThreadSafedMap {
private:
    struct Bucket {
        using BucketValue = std::pair<Key, Value>;
        using BucketData = std::list<BucketValue>;
        using BucketPtr = std::shared_ptr<const BucketData>;

        mutable std::shared_mutex mutex;  // 读写锁
        std::atomic<BucketPtr> atomicData; // 原子指针指向不可变数据

        Bucket() : atomicData(std::make_shared<BucketData>()) {}

        // 插入或更新键值对（原子替换）
        void insert(const Key& key, const Value& value) {
            std::unique_lock lock(mutex); // 写锁独占
            auto newData = std::make_shared<BucketData>(*atomicData.load());
            auto it = std::find_if(newData->begin(), newData->end(),
                [&](const auto& item) { return item.first == key; });
            if (it != newData->end()) it->second = value;
            else newData->emplace_back(key, value);
            atomicData.store(newData); // 原子替换
        }

        // 查找数据（无锁读）
        std::optional<Value> find(const Key& key) const {
            auto localData = atomicData.load(); // 原子加载
            auto it = std::find_if(localData->begin(), localData->end(),
                [&](const auto& item) { return item.first == key; });
            return (it != localData->end()) ? std::make_optional(it->second) : std::nullopt;
        }
    };

    std::vector<Bucket> buckets;  // 分桶数组
    Hash hasher;

    Bucket& getBucket(const Key& key) const {
        return buckets[hasher(key) % buckets.size()];
    }

public:
    ThreadSafeFineGrainedMap(size_t bucketCount = 19) : buckets(bucketCount) {}

    void insert(const Key& key, const Value& value) {
        getBucket(key).insert(key, value); // 仅锁定单个桶
    }

    std::optional<Value> find(const Key& key) const {
        return getBucket(key).find(key);   // 无锁读
    }
};
