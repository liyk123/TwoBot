// Generated by DeepSeek-R1

#include <atomic>
#include <shared_mutex>
#include <vector>
#include <map>
#include <memory>
#include <optional>
#include <functional>

namespace twobot {
    template <typename Key, typename Value, typename Hash = std::hash<Key>>
    class ThreadSafedUnorderedMap {
    private:
        struct Bucket {
            using BucketData = std::unordered_map<Key, Value>;
            using BucketPtr = std::shared_ptr<const BucketData>;

            mutable std::shared_mutex mutex;  // 读写锁
            std::atomic<BucketPtr> atomicData; // 原子指针指向不可变数据

            Bucket() 
                : atomicData(std::make_shared<BucketData>())
                , mutex()
            {}

            // 构造键值对（原子替换）
            void emplace(const Key& key, const Value& value) {
                std::lock_guard lock(mutex); // 写锁独占
                auto newData = std::make_shared<BucketData>(*atomicData.load());
                newData->emplace(key, value);
                atomicData.store(newData);
            }

            // 删除值对（原子替换）
            void erase(const Key& key) {
                std::lock_guard lock(mutex); // 写锁独占
                auto newData = std::make_shared<BucketData>(*atomicData.load());
                newData->erase(key);
                atomicData.store(newData); // 原子替换
            }

            // 查找数据（无锁读）
            std::optional<Value> find(const Key& key) {
                auto localData = atomicData.load(); // 原子加载
                auto it = localData->find(key);
                return (it != localData->end()) ? std::make_optional(it->second) : std::nullopt;
            }
        };

        std::vector<Bucket> buckets;  // 分桶数组
        Hash hasher;

        auto &getBucket(const Key& key) {
            return buckets[hasher(key) % buckets.size()];
        }

    public:
        ThreadSafedUnorderedMap(const std::size_t bucketCount = std::thread::hardware_concurrency()) 
            : buckets(bucketCount)
            , hasher()
        {}

        void emplace(const Key& key, const Value& value) {
            getBucket(key).emplace(key, value); // 仅锁定单个桶
        }

        void erase(const Key& key) {
            getBucket(key).erase(key); // 仅锁定单个桶
        }

        std::optional<Value> find(const Key& key) {
            return getBucket(key).find(key);   // 无锁读
        }
    };
}
